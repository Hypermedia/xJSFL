///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// Art Brush.include
// By David Johnston
// Last modified Tuesday, April 06, 2010
// v1.1
//
// Include file for the Art Brush and the Distribute Symbol Along Path
// commands.
//
// v1.1 Added the ability to add vertices to the brush stroke to make it
// follow the path almost perfectly
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

var DUMMY_TRANSPARENCY = "#12345600"
var MAX_EDGE_SUBDIVISION = 0;        // Max number of recursions when subdividing an edge
var LINEAR_THRESHOLD = 1e-13;        // coefficients below this will be considered 0

fl.runScript( fl.configURI + "Commands/auto tween.include" );

///////////////////////////////////////////////////////////////////////////
// Returns true if both passed edges have the same control points
///////////////////////////////////////////////////////////////////////////

sameEdge = function(edge0, edge1)
{
	return (edge0.id == edge1.id);
}

///////////////////////////////////////////////////////////////////////////
// Returns the intersection of two lines defined by the given start points
// and the given vectors from those points.
///////////////////////////////////////////////////////////////////////////

var INTERSECTION_PARALLEL = -1;
var INTERSECTION_OUTSIDE = -2;

getIntersectionPoint = function(pt1, vec1, pt2, vec2, ray)
{
	if(ray == undefined)
		ray = true;
		
	var a1, b1, c1, a2, b2, c2;
	var retval = {};
	
	a1 = vec1.y;
	b1 = -vec1.x;
	c1 = a1 * pt1.x + b1 * pt1.y;
	a2 = vec2.y;
	b2 = -vec2.x;
	c2 = a2 * pt2.x + b2 * pt2.y;
	
	//fl.trace("a1 = " + a1 + ", b1 = " + b1 + ", c1 = " + c1);
	//fl.trace("a2 = " + a2 + ", b2 = " + b2 + ", c2 = " + c2);
	
	var determinant = a1*b2 - a2*b1;
	if(determinant == 0)
	{
		//fl.trace("parallel lines");
		
		return INTERSECTION_PARALLEL;
	}
	else
	{
		retval.x = (b2*c1 - b1*c2)/determinant;
		retval.y = (a1*c2 - a2*c1)/determinant;
		//fl.trace("intersection point: " + retval.x + ", " + retval.y);
	}
	
	if(ray)
	{
		// Now retval has the intersection point of the two lines
		// Let's make sure it's in the direction of the vectors
		
		var x1_dir = vec1.x / Math.abs(vec1.x);
		var y1_dir = vec1.y / Math.abs(vec1.y);
		var x2_dir = vec2.x / Math.abs(vec2.x);
		var y2_dir = vec2.y / Math.abs(vec2.y);
		
		if(x1_dir * (retval.x - pt1.x) < 0 ||
		   y1_dir * (retval.y - pt1.y) < 0 ||
		   x2_dir * (retval.x - pt2.x) < 0 ||
		   y2_dir * (retval.y - pt2.y) < 0)
		{
			//fl.trace("pt1 isn't between pt0 and pt2: " + retval.x + ", " + retval.y);
			return INTERSECTION_OUTSIDE;
		}
	}
	
	return retval;
}


makeSelectionInvisible = function()
{
	var invisibleFill = doc.getCustomFill("toolbar");
	var invisibleStroke = doc.getCustomStroke("toolbar");
	
	invisibleFill.color = DUMMY_TRANSPARENCY;
	invisibleFill.style = "solid";
	invisibleStroke.style = "solid";
	invisibleStroke.shapeFill = invisibleFill;
	
	doc.setCustomFill(invisibleFill);
	doc.setCustomStroke(invisibleStroke);
}

///////////////////////////////////////////////////////////////////////////
// Returns an array of objects representing the edges in the contour, in 
// order of traversal
///////////////////////////////////////////////////////////////////////////

getContourEdgeOrder = function(contour)
{
	var otherStartPoint;
	var otherEndPoint;
	var curStartPoint;
	var curEndPoint;
	var edges = [];

	edges.length = 0;	
	var he = contour.getHalfEdge();
	var startEdge = curEdge = he.getEdge();
	do
	{
		edges.push({pt0: curEdge.getControl(0), pt1: curEdge.getControl(1), pt2: curEdge.getControl(2)});
		
		he = he.getNext();
		curEdge = he.getEdge();
	}
	while(!sameEdge(curEdge, startEdge));
	
	//fl.trace("There are " + edges.length + " edges in this contour");
	
	var edgeOrd = new Array;
	
	for(curIndex = 0; curIndex < edges.length; curIndex++)
	{
		// Zero out all the edge order entries
		edgeOrd[curIndex] = {prev:undefined, next:undefined};
	}
	
	curIndex = 0;
	do
	{
		curStartPoint = edges[curIndex].pt0;
		curEndPoint   = edges[curIndex].pt2;
		
		for(otherIndex = 0; otherIndex < edges.length; otherIndex++)
		{
			if(curIndex != otherIndex)
			{
				// If we've already found next and prev for this edge, don't look any more
				if(edgeOrd[curIndex].next != undefined && edgeOrd[curIndex].prev != undefined)
					break;
					
				otherStartPoint = edges[otherIndex].pt0;
				otherEndPoint   = edges[otherIndex].pt2;
				
				if(edgeOrd[curIndex].next == undefined)
				{
					if(curEndPoint.x == otherStartPoint.x && curEndPoint.y == otherStartPoint.y)
					{
						edgeOrd[curIndex].next = otherIndex;
						edgeOrd[otherIndex].prev = curIndex;
						//fl.trace("1: edge " + curIndex + " goes to " + otherIndex);
						break;
					}
					else if(curEndPoint.x == otherEndPoint.x && curEndPoint.y == otherEndPoint.y)
					{
						// This end point meets the other end point.
						// Switch around the start and end points of the other edge so 
						// we have consistent orientation
						var tempPt = edges[otherIndex].pt0;
						edges[otherIndex].pt0 = edges[otherIndex].pt2;
						edges[otherIndex].pt2 = tempPt;
	
						edgeOrd[curIndex].next = otherIndex;
						edgeOrd[otherIndex].prev = curIndex;
						//fl.trace("2: edge " + curIndex + " goes to " + otherIndex);
						break;
					}
				}
			}
		}
		// Now edgeOrd[curIndex].next should be set.  Make that one the next edge to work on
		curIndex = edgeOrd[curIndex].next;
	}
	while(curIndex != 0);

	// We only care about the edge starting at index 0, because that's the one
	// that we know is in the contour
	var startIndex = 0;
	// An array of edge indices
	var retArray = [];	
	
	curIndex = startIndex;
	do
	{
		retArray.push(edges[curIndex]);
		curIndex = edgeOrd[curIndex].next;
	}
	while(curIndex != undefined && curIndex != startIndex);

	if(curIndex == undefined)
		 fl.trace("ERROR!!! unclosed path on a contour!");

	return retArray;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

getBrushShape = function()
{
	var item = doc.library.getSelectedItems()[0];
	var theShape = item.timeline.layers[0].frames[0].elements[0];
	if(theShape.elementType == "shape")
	{
		return theShape;
	}
}

///////////////////////////////////////////////////////////////////////////
//=========================================================================
// Gauss-Legendre numerical integration
//
// Adapted from:
// http://code.google.com/p/degrafa/source/browse/branches/Origin/Degrafa/com/degrafa/utilities/math/Gauss.as?r=459&spec=svn459
//=========================================================================
///////////////////////////////////////////////////////////////////////////


function Gauss()
{
	this.MAX_POINTS     = 8;

	this.abscissa = new Array();
	this.weight   = new Array();
	
	// N=2
	this.abscissa.push(-0.5773502692);
	this.abscissa.push( 0.5773502692);
	
	this.weight.push(1);
	this.weight.push(1);
	
	// N=3
	this.abscissa.push(-0.7745966692);
	this.abscissa.push( 0.7745966692);
	this.abscissa.push(0);
	
	this.weight.push(0.5555555556);
	this.weight.push(0.5555555556);
	this.weight.push(0.8888888888);
	
	// N=4
	this.abscissa.push(-0.8611363116);
	this.abscissa.push( 0.8611363116);
	this.abscissa.push(-0.3399810436);
	this.abscissa.push( 0.3399810436);
	
	this.weight.push(0.3478548451);
	this.weight.push(0.3478548451);
	this.weight.push(0.6521451549);
	this.weight.push(0.6521451549);
	
	// N=5
	this.abscissa.push(-0.9061798459);
	this.abscissa.push( 0.9061798459);
	this.abscissa.push(-0.5384693101);
	this.abscissa.push( 0.5384693101);
	this.abscissa.push( 0.0000000000);
	
	this.weight.push(0.2369268851);
	this.weight.push(0.2369268851);
	this.weight.push(0.4786286705);
	this.weight.push(0.4786286705);
	this.weight.push(0.5688888888);
	
	// N=6
	this.abscissa.push(-0.9324695142);
	this.abscissa.push( 0.9324695142);
	this.abscissa.push(-0.6612093865);
	this.abscissa.push( 0.6612093865);
	this.abscissa.push(-0.2386191861);
	this.abscissa.push( 0.2386191861);
	
	this.weight.push(0.1713244924);
	this.weight.push(0.1713244924);
	this.weight.push(0.3607615730);
	this.weight.push(0.3607615730);
	this.weight.push(0.4679139346);
	this.weight.push(0.4679139346);
	
	// N=7
	this.abscissa.push(-0.9491079123);
	this.abscissa.push( 0.9491079123);
	this.abscissa.push(-0.7415311856);
	this.abscissa.push( 0.7415311856);
	this.abscissa.push(-0.4058451514);
	this.abscissa.push( 0.4058451514);
	this.abscissa.push( 0.0000000000);
	
	this.weight.push(0.1294849662);
	this.weight.push(0.1294849662);
	this.weight.push(0.2797053915);
	this.weight.push(0.2797053915);
	this.weight.push(0.3818300505);
	this.weight.push(0.3818300505);
	this.weight.push(0.4179591837);
	
	// N=8
	this.abscissa.push(-0.9602898565);
	this.abscissa.push( 0.9602898565);
	this.abscissa.push(-0.7966664774);
	this.abscissa.push( 0.7966664774);
	this.abscissa.push(-0.5255324099);
	this.abscissa.push( 0.5255324099);
	this.abscissa.push(-0.1834346425);
	this.abscissa.push( 0.1834346425);
	
	this.weight.push(0.1012285363);
	this.weight.push(0.1012285363);
	this.weight.push(0.2223810345);
	this.weight.push(0.2223810345);
	this.weight.push(0.3137066459);
	this.weight.push(0.3137066459);
	this.weight.push(0.3626837834);
	this.weight.push(0.3626837834);
}

/**
* @param _f:Function - Reference to function to be integrated - must accept a numerical argument and return
*                      the function value at that argument.
*
* @param _a:Number   - Left-hand value of interval.
* @param _b:Number   - Right-hand value of inteval.
* @param _n:Number   - Number of points -- must be between 2 and 8
*
* @return Number - approximate integral value over [_a, _b] or 0 if an error condition occured.  Assign a handler for the
* 'invalid_parameters' event.  The three possible error conditions are 1) non-numeric values for the interval,  2) an invalid
* interval, 3) an invalid function reference, and 4) an invalid number of samples (must be between two and 8
*
* @since 1.0
*
*/

Gauss.prototype.eval = function(_f, _a, _b, _n)
{
	//fl.trace("Gauss.prototype.eval");
	
	// evaluate the integral over the specified interval
	if( isNaN(_a) || isNaN(_b) )
	{
		//fl.trace("_a or _b is NaN");
		return 0;
	}
	
	if(_a == _b)
	{
		return 0;
	}
	
	if( _a > _b )
	{
		//fl.trace("_a > _b");
		return 0;
	}
	
	if( !(typeof _f == "function") )
	{
		//fl.trace("_f isn't a function");
		return 0;
	}
	
	if( isNaN(_n) || _n < 2 )
	{
		//fl.trace("_n is NaN or is < 2");
		return 0;
	}
	
	var n = Math.max(_n,2);
	n     = Math.min(n,this.MAX_POINTS);
	
	var l   = (n==2) ? 0 : n*(n-1)/2 - 1;
	var sum = 0;
	
	if( _a == -1 && _b == 1 )
	{
		for( var i=0; i<n; ++i )
			sum += _f(this.abscissa[l+i])*this.weight[l+i];
		
		//fl.trace("returning " + sum);
		return sum;
	}
	else
	{
		// change of variable
		var mult = 0.5*(_b-_a);
		var ab2  = 0.5*(_a+_b);
		for( i=0; i<n; ++i )
		{
			//fl.trace("_f(" + ab2 + " + " + mult + "*" + this.abscissa[l+i] + ")*" + this.weight[l+1]);
			sum += _f(ab2 + mult*this.abscissa[l+i])*this.weight[l+i];
		}
		
		//fl.trace("2returning " + sum + " * " + mult);
		return mult*sum;
	}
}

///////////////////////////////////////////////////////////////////////////
//=========================================================================
// Bezier class
// 
//
// Adapted the length estimation functions for quadratic beziers from:
// http://www.algorithmist.net/bezierarclength/srcview/index.html
//
// See the working demo here: 
// http://www.algorithmist.net/bezierarclength/DegrafaTemplate.html
//=========================================================================
///////////////////////////////////////////////////////////////////////////

function Bezier(_ptA, _ptB, _ptC)
{
	this.LINEAR_SAMPLE_TABLE_SIZE = 20;

	this.integrate = new Gauss();
	this.setControls(_ptA, _ptB, _ptC);
		
	var me = this;
	
	//-------------------------------------------------------------------------

	// integrand for Gauss-Legendre numerical integration
	// This is defined in the constructor so it can remember the me var as a callback
	this.integrand = function(_t)
	{
		//fl.trace("c1X = " + me.c1X + ", c1Y = " + me.c1Y + ", c2X = " + me.c2X + ", c2Y = " + me.c2Y);
		//fl.trace("pointA = " + me.pointA.x + ", " + me.pointA.y + ", pointB = " + me.pointB.x + ", " + me.pointB.y + ", pointC = " + me.pointC.x + ", " + me.pointC.y);
		// first-derivative of the quad. bezier
		var xPrime = me.c1X + 2.0*me.c2X*_t;
		var yPrime = me.c1Y + 2.0*me.c2Y*_t;
		
		//fl.trace("integrand returns " + Math.sqrt(xPrime*xPrime + yPrime*yPrime));
		return Math.sqrt( xPrime*xPrime + yPrime*yPrime );
	}
}

//-------------------------------------------------------------------------

Bezier.prototype.setControls = function(_ptA, _ptB, _ptC)
{
	this.pointA = {x:_ptA.x, y:_ptA.y};
	this.pointB = {x:_ptB.x, y:_ptB.y};
	this.pointC = {x:_ptC.x, y:_ptC.y};
	this.computeBezierCoef();
	this.paramTableReady = false;
}

//-------------------------------------------------------------------------
// compute the quad. bezier coefficients

Bezier.prototype.computeBezierCoef = function()
{
	//fl.trace("Setting coefficients from: " + this.pointA.x + ", " + this.pointA.y);
	//fl.trace("                           " + this.pointB.x + ", " + this.pointB.y);
	//fl.trace("                           " + this.pointC.x + ", " + this.pointC.y);
	
	// Constant
	this.c0X = this.pointA.x;
	this.c0Y = this.pointA.y;
	
	// Linear
	this.c1X = 2.0*(this.pointB.x-this.pointA.x);
	this.c1Y = 2.0*(this.pointB.y-this.pointA.y);
	
	// Square
	this.c2X = this.pointA.x-2.0*this.pointB.x+this.pointC.x;
	this.c2Y = this.pointA.y-2.0*this.pointB.y+this.pointC.y;
	
	var xBelowThresh = (this.c2X > -LINEAR_THRESHOLD && this.c2X < LINEAR_THRESHOLD);
	var yBelowThresh = (this.c2Y > -LINEAR_THRESHOLD && this.c2Y < LINEAR_THRESHOLD);
	
	if(xBelowThresh && yBelowThresh)
	{
		//fl.trace("============================== SMALLER THAN LINEAR THRESHOLD!");
		//fl.trace("this.c2X = " + this.c2X);
		//fl.trace("this.pointA: " + this.pointA.x + ", " + this.pointA.y);
		//fl.trace("this.pointB: " + this.pointB.x + ", " + this.pointB.y);
		//fl.trace("this.pointC: " + this.pointC.x + ", " + this.pointC.y);
		this.c2X = 0;
		this.c2Y = 0;
	}
}

//-------------------------------------------------------------------------

Bezier.prototype.getPointNatural = function(_t)
{
	//fl.trace("t = " + _t);
	//fl.trace("c0X = " + this.c0X + ", c0Y = " + this.c0Y + ", c1X = " + this.c1X + ", c1Y = " + this.c1Y + ", c2X = " + this.c2X + ", c2Y = " + this.c2Y);
	//fl.trace("pointA = " + this.pointA.x + ", " + this.pointA.y + ", pointB = " + this.pointB.x + ", " + this.pointB.y + ", pointC = " + this.pointC.x + ", " + this.pointC.y);
	var retPt = {x:this.c0X + this.c1X*_t + this.c2X*_t*_t, y:this.c0Y + this.c1Y*_t + this.c2Y*_t*_t} 
	return retPt;
}

//-------------------------------------------------------------------------

Bezier.prototype.getPointFromLength = function(_len)
{
	var t = this.getParamFromLength(_len);
	//fl.trace("bezier.getPointFromLength(" + _len + "): t = " + t);
	return this.getPointNatural(t);
}

//-------------------------------------------------------------------------

Bezier.prototype.getTangentVector = function(_t)
{
	var tanVec = new Object;
	
	//fl.trace("pointA = " + this.pointA.x + ", " + this.pointA.y + ", pointB = " + this.pointB.x + ", " + this.pointB.y + ", pointC = " + this.pointC.x + ", " + this.pointC.y);
	tanVec.x = this.pointB.x - this.pointA.x + this.c2X * _t;
	tanVec.y = this.pointB.y - this.pointA.y + this.c2Y * _t;
	
	return tanVec;
}

//-------------------------------------------------------------------------

Bezier.prototype.getTangent = function(_t)
{
	return getAngle(this.getTangentVector(_t));
}

//-------------------------------------------------------------------------

Bezier.prototype.initLinearParamTable = function()
{
	this.linearParamTable = [];
	var n;
	this.linearParamTable[0] = 0;
	for(n = 1; n < this.LINEAR_SAMPLE_TABLE_SIZE; n++)
	{
		this.linearParamTable.push(this.getLengthPrecise(0, n / (this.LINEAR_SAMPLE_TABLE_SIZE - 1)));
		//fl.trace("" + (n / (this.LINEAR_SAMPLE_TABLE_SIZE - 1)) + " maps to " + this.linearParamTable[this.linearParamTable.length - 1]);
	}
	
	this.length = this.linearParamTable[this.LINEAR_SAMPLE_TABLE_SIZE - 1];
	
	this.paramTableReady = true;
}

//-------------------------------------------------------------------------
// This function expects non-normalized length as the parameter

Bezier.prototype.getParamFromLength = function(_len)
{	
	this.length = this.getLength();
	
	//fl.trace("getParamFromLength: looking for length " + _len + " in bez of length " + this.length);

	/*
	if(_len <= 0)
		return 0;
	if(_len >= this.length)
		return 1;
	*/
		
	//fl.trace("Bezier length is " + this.length);

	// Make sure the parameter table has been built
	if(!this.paramTableReady)
	{
		//fl.trace("initializing param table");
		this.initLinearParamTable();
	}
	
	//fl.trace("Bezier length is " + this.length);

	// Do a binary search to find the two table entries that surround the requested length
	var top = this.linearParamTable.length - 1;
	var bottom = 0;
	//fl.trace("zeroing in on a likely suspect for target length " + _len);
	while(this.linearParamTable[bottom + 1] < _len && this.linearParamTable[bottom + 1] != this.length)
	{
		var middle = ((bottom + top) / 2) | 0;
		//fl.trace("" + _len + ": top = " + this.linearParamTable[top] + ", middle = " + this.linearParamTable[middle] + ", bottom = " + this.linearParamTable[bottom]);
		if(this.linearParamTable[middle] <= _len)
			bottom = middle;
		else top = middle;
		//for(z = 0; z < 1000000; z++);  // slow-downer
	}
	
	// Now we have upper and lower limits.  Do a linear interpolation 
	// between those to get the return value
	
	// These vars are just for readability
	aLen = this.linearParamTable[bottom];
	bLen = this.linearParamTable[bottom + 1];
	
	// Find the natural parameter via linear interpolation between the table entries
	var retval = (bottom + (_len - aLen) / (bLen - aLen)) / (this.linearParamTable.length - 1);
	
	//fl.trace("found t = " + retval + " for " + _len + " out of " + this.length);
	
	return retval;
}

//-------------------------------------------------------------------------
// approximate arc-length by linear interpolation from a pre-calculated table

Bezier.prototype.getLength = function()
{	
	if(this.paramTableReady)
	{
		//fl.trace("length was already calculated");
		return this.length;
	}
	else
	{
		//fl.trace("calculating length anew");
		return this.getLengthPrecise(0,1);
	}
}


//-------------------------------------------------------------------------
// approximate arc-length by numerical integration

Bezier.prototype.getLengthPrecise = function(_t1, _t2)
{	
	// arc length along curve from t1 to t2
	return this.integrate.eval(this.integrand, _t1, _t2, 5);
}
        
//-------------------------------------------------------------------------
// Returns an array of the t values where the x coord == _x
// Returns an empty array if there are no intersections in 0<=t<=1

Bezier.prototype.getXIntercepts = function(_x)
{	
	// I'm gonna use the quadratic equation.

	var t0, t1;
	var a = this.c2X, b = this.c1X, c = this.c0X - _x;
	
	//fl.trace("testing edge for intersection with " + _x);
	//fl.trace("a = " + a + ", b = " + b + ", c = " + c);
	//fl.trace("this.pointA: " + this.pointA.x + ", " + this.pointA.y);
	//fl.trace("this.pointB: " + this.pointB.x + ", " + this.pointB.y);
	//fl.trace("this.pointC: " + this.pointC.x + ", " + this.pointC.y);
	if(a != 0)
	{
		var discriminant = b*b - 4*a*c;
		//fl.trace("discriminant is " + discriminant);
		
		// If the discriminant is >= 0 then there is at least one intersection, though maybe not in 0<=t<=1
		if(discriminant >= 0)
		{
			var retArray = [];
			t0 = (-b + Math.sqrt(discriminant)) / (2 * a);
			t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
			
			if(t0 < t1)
			{
				//fl.trace("t0 < t1: t0 = " + t0 + ", t1 = " + t1);
				if(t0 > 0 && t0 < 1)
					retArray.push(t0);
				if(t1 > 0 && t1 < 1)
					retArray.push(t1);
			}
			else if(t0 > t1)
			{
				//fl.trace("t0 > t1: t0 = " + t0 + ", t1 = " + t1);
				if(t1 > 0 && t1 < 1)
					retArray.push(t1);
				if(t0 > 0 && t0 < 1)
					retArray.push(t0);
			}
			else if(t0 >= 0 && t0 <= 1)
			{
				//fl.trace("pushing t0");
				retArray.push(t0);
			}
			
			//fl.trace("retArray has " + retArray.length + " elements");
			return retArray;
		}
		else
			return [];
	}
	else if(this.pointA.x != this.pointC.x)
	{
		var t = (_x - this.pointA.x) / (this.pointC.x - this.pointA.x);
		//fl.trace("linear, t = " + t);
		if(t > 0 && t < 1)
		{
			//fl.trace("returning an intersection with a straight line");
			return [t];
		}
		else return [];
	}
	else
		return [];
}
        
///////////////////////////////////////////////////////////////////////////
// Returns an array representing the order of the edges in the passed array
///////////////////////////////////////////////////////////////////////////

getEdgeOrderQuad = function(_edges)
{
	var otherStartPoint;
	var otherEndPoint;
	var curStartPoint;
	var curEndPoint;
	var curIndex;
	
	var startEdge = undefined;
	
	var edgeOrd = [];
	var edges = [];
	
	for(var n = 0; n < _edges.length; n++)
	{
		var temp = {pt0: _edges[n].getControl(0), pt1: _edges[n].getControl(1), pt2: _edges[n].getControl(2)};
		edges.push(temp);
		//fl.trace("getEdgeOrderQuad" + temp.pt0.x + ", " + temp.pt0.y);
		//fl.trace("                " + temp.pt1.x + ", " + temp.pt1.y);
		//fl.trace("                " + temp.pt2.x + ", " + temp.pt2.y);

	}
	
	for(curIndex = 0; curIndex < edges.length; curIndex++)
	{
		// Zero out all the edge order entries
		edgeOrd[curIndex] = {prev:undefined, next:undefined};
	}
	
	for(var startIndex = 0; startIndex < edges.length; startIndex++)
	{
		if(edgeOrd[startIndex].next == undefined)
		{
			curIndex = startIndex;
			do
			{
				curStartPoint = edges[curIndex].pt0;
				curEndPoint   = edges[curIndex].pt2;
				
				for(otherIndex = 0; otherIndex < edges.length; otherIndex++)
				{
					if(curIndex != otherIndex)
					{
						// If we've already found next and prev for this edge, don't look any more
						if(edgeOrd[curIndex].next != undefined && edgeOrd[curIndex].prev != undefined)
							break;
							
						otherStartPoint = edges[otherIndex].pt0;
						otherEndPoint   = edges[otherIndex].pt2;
						
						if(edgeOrd[curIndex].next == undefined)
						{
							if(curEndPoint.x == otherStartPoint.x && curEndPoint.y == otherStartPoint.y)
							{
								edgeOrd[curIndex].next = otherIndex;
								edgeOrd[otherIndex].prev = curIndex;
								//fl.trace("1: edge " + curIndex + " goes to " + otherIndex);
								break;
							}
							else if(curEndPoint.x == otherEndPoint.x && curEndPoint.y == otherEndPoint.y)
							{
								// This end point meets the other end point.
								// Switch around the start and end points of the other edge so 
								// we have consistent orientation
								var tempPt = edges[otherIndex].pt0;
								edges[otherIndex].pt0 = edges[otherIndex].pt2;
								edges[otherIndex].pt2 = tempPt;
			
								edgeOrd[curIndex].next = otherIndex;
								edgeOrd[otherIndex].prev = curIndex;
								//fl.trace("2: edge " + curIndex + " goes to " + otherIndex);
								break;
							}
						}
					}
				}
				// Now edgeOrd[curIndex].next should be set.  Make that one the next edge to work on
				curIndex = edgeOrd[curIndex].next;
				//fl.trace("curIndex: " + curIndex);
			}
			while(curIndex != startIndex && curIndex != undefined);
		}
	}

	var startArray = [];
	var startIndex = 0;
	var thisPath;
	var retArray = new Array();
	var edgeVisited = [];
	
	// Build arrays starting with all the edges with no previous edge

	for(curIndex = 0; curIndex < edges.length; curIndex++)
	{
		edgeVisited[curIndex] = false;
		if(edgeOrd[curIndex].prev == undefined)
		{
			startArray.push(curIndex);
		}
	}
	
	while(startArray.length)
	{
		curIndex = startIndex = startArray.pop();
		//fl.trace("starting a path at " + edges[curIndex].pt0.x + ", " + edges[curIndex].pt0.y);
		thisPath = [];
		do
		{
			//fl.trace("new edge " + curIndex + ": " + edges[curIndex].pt0.x + ", " + edges[curIndex].pt0.y + " -> " + edges[curIndex].pt2.x + ", " + edges[curIndex].pt2.y);
			thisPath.push(edges[curIndex]);
			edgeVisited[curIndex] = true;
			//fl.trace("edgeVisited[" + curIndex + "] = " + edgeVisited[curIndex]);
			curIndex = edgeOrd[curIndex].next;
		}
		while(curIndex != undefined && !edgeVisited[curIndex]);
		retArray.push(thisPath);
	}
	
	// and now add arrays with edges that are unaccounted for.
	for(startIndex = 0; startIndex < edges.length; startIndex++)
	{
		if(!edgeVisited[startIndex])
		{			
			curIndex = startIndex;
			//fl.trace("2: starting a path at " + edges[curIndex].pt0.x + ", " + edges[curIndex].pt0.y);
			thisPath = [];
			do
			{
				//fl.trace("new edge " + curIndex + ": " + edges[curIndex].pt0.x + ", " + edges[curIndex].pt0.y + " -> " + edges[curIndex].pt2.x + ", " + edges[curIndex].pt2.y);
				//fl.trace("edgeVisited[" + curIndex + "] = " + edgeVisited[curIndex]);
				thisPath.push(edges[curIndex]);
				edgeVisited[curIndex] = true;
				curIndex = edgeOrd[curIndex].next;
			}
			while(curIndex != undefined && curIndex != startIndex && !edgeVisited[curIndex]);
			retArray.push(thisPath);
		}
	}
	
	return retArray;
}

///////////////////////////////////////////////////////////////////////////
// Return the angle of the given vector
///////////////////////////////////////////////////////////////////////////

function getAngle(vec)
{
	//fl.trace("getAngle " + vec.x + ", " + vec.y);
	var retval = new Object();
	if(vec.x != 0)
	{
		//fl.trace("getAngle vec.x != 0");
		retval = Math.atan(vec.y / vec.x);
	}
	else 
	{
		//fl.trace("getAngle vec.x >= 0");
		if(vec.y > 0)	
			retval = Math.PI / 2.0;
		else if(vec.y < 0)
			retval = -Math.PI / 2.0;
		else retval = 0;
		//fl.trace("... and retval = " + retval);		
	}
	if(vec.x < 0)
		retval += Math.PI;
		
	if(retval < 0)
		retval += Math.PI * 2;
		
	//fl.trace("getAngle returning " + retval);	
	
	return retval;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

doc = fl.getDocumentDOM();
